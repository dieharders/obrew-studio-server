name: 'Manual Release'

on:
  workflow_dispatch:
    inputs:
      release_name:
        description: 'Release title'
        required: true
      release_type:
        description: 'Type of release (draft, private, public)'
        required: true
        default: 'draft'
      release_notes:
        description: 'Release notes'
        required: false

# permissions:
#     # Give the default GITHUB_TOKEN write permission to commit and push the
#     # added or changed files to the repository.
#     contents: write

jobs:
  build:
    name: Build for ${{ matrix.os }}
    # needs: create_release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, macos-latest] # builds for each platform, in seperate vm's, in this order
    continue-on-error: true
    steps:
      # 1. Pull down repo
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for proper Git submodule initialization
          ref: ${{ github.event.inputs.ref || github.ref }} # checks out code you specify in github UI

      # 2. Install Python
      - name: Install Python
        id: setup_python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12.8'
          # cache: 'pip' # caches the downloaded package installers only, if you cache the venv then disabling this will save about 20s

      # 3. Load the cached python virtual environment
      - name: Restore cached venv
        id: restore-cache
        uses: actions/cache/restore@v4
        with:
          key: venv-${{ runner.os }}-${{ steps.setup_python.outputs.python-version }}-${{ hashFiles('requirements.txt') }}
          path: .venv

      # 4. Create virtual environment, Install package manager and dependencies for Python
      - name: Setup venv - Windows (install deps)
        shell: bash
        if: runner.os == 'Windows'
        run: |
          python -m venv .venv # noop if cache is found
          .venv/Scripts/activate
          .venv/Scripts/python -m pip list  # Verify installed packages
          # Install pip and Python deps
          .venv/Scripts/python --version
          .venv/Scripts/python -m pip install --upgrade pip setuptools wheel # upgrades pip to latest
          .venv/Scripts/python -m pip install -r requirements.txt # install deps, use --prefer-binary to install from wheels instead of source

      - name: Setup venv - macOS (install deps)
        shell: bash
        if: runner.os == 'macOS'
        run: |
          python -m venv .venv # noop if cache is found
          source .venv/bin/activate
          .venv/bin/python -m pip list  # Verify installed packages
          # Install pip and Python deps
          .venv/bin/python --version
          .venv/bin/python -m pip install --upgrade pip setuptools wheel # upgrades pip to latest
          .venv/bin/python -m pip install -r requirements.txt # install deps, use --prefer-binary to install from wheels instead of source

      # 5. Cache python virtual environment for later runs
      - name: Save cached venv
        if: steps.restore-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          key: venv-${{ runner.os }}-${{ steps.setup_python.outputs.python-version }}-${{ hashFiles('requirements.txt') }}
          path: .venv

      # - name: List contents of GitHub workspace
      #   shell: bash
      #   run: |
      #     echo "Contents of the GitHub workspace directory:"
      #     ls -al "${{ github.workspace }}"
      #     echo ".venv/lib/site-packages"
      #     ls -al .venv/lib/site-packages
      #     echo "Contents of the Python directory:"
      #     ls -al "${{ env.pythonLocation }}"

      # Download mkcert binaries (required for SSL certificate installation)
      - name: Download mkcert binaries
        shell: bash
        run: |
          bash certs/download-mkcert.sh
          echo "mkcert binaries downloaded:"
          ls -lh certs/mkcert-*

      # Build llama.cpp from source for macOS
      # - name: Build llama.cpp from source (macOS)
      #   if: runner.os == 'macOS'
      #   shell: bash
      #   run: |
      #     # Read llama.cpp tag from package.json
      #     LLAMA_TAG=$(grep '"llamacpp_tag"' package.json | cut -d'"' -f4)
      #     echo "Building llama.cpp at tag: $LLAMA_TAG"

      #     # Clone llama.cpp repository
      #     git clone https://github.com/ggerganov/llama.cpp.git llama-cpp-build
      #     cd llama-cpp-build
      #     git checkout "tags/$LLAMA_TAG"

      #     # Build with Metal support
      #     cmake -B build \
      #       -DGGML_METAL=ON \
      #       -DLLAMA_CURL=OFF \
      #       -DCMAKE_BUILD_TYPE=Release \
      #       -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
      #     cmake --build build --config Release -j $(sysctl -n hw.ncpu)

      #     # Create directory structure
      #     mkdir -p "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp"

      #     # Copy binaries
      #     cp build/bin/llama-cli "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/"
      #     cp build/bin/llama-embedding "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/"

      #     # Copy Metal shaders and headers
      #     cp build/bin/ggml-metal.metal "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" || true
      #     cp ggml/include/ggml-metal.h "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" || true
      #     cp ggml/src/ggml-common.h "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" || true

      #     # Copy dynamic libraries
      #     cp build/src/libllama.dylib "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" || true
      #     cp build/ggml/src/libggml.dylib "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" || true
      #     cp build/ggml/src/libggml-base.dylib "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" || true
      #     cp build/ggml/src/libggml-metal.dylib "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" || true

      #     # List compiled files
      #     echo "Compiled llama.cpp files:"
      #     ls -lh "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/"
      #     cd "${{ github.workspace }}"

      # Install CUDA Toolkit for Windows (required for llama.cpp compilation)
      # - name: Install CUDA Toolkit (Windows)
      #   if: runner.os == 'Windows'
      #   uses: Jimver/cuda-toolkit@v0.2.16
      #   id: cuda-toolkit
      #   with:
      #     cuda: '12.4.0'
      #     method: 'network'

      # Build llama.cpp from source for Windows
      # - name: Build llama.cpp from source (Windows)
      #   if: runner.os == 'Windows'
      #   shell: pwsh
      #   run: |
      #     # Read llama.cpp tag from package.json
      #     $packageJson = Get-Content package.json | ConvertFrom-Json
      #     $llamaTag = $packageJson.llamacpp_tag
      #     Write-Host "Building llama.cpp at tag: $llamaTag"

      #     # Clone llama.cpp repository
      #     git clone https://github.com/ggerganov/llama.cpp.git llama-cpp-build
      #     cd llama-cpp-build
      #     git checkout "tags/$llamaTag"

      #     # Build with CUDA support
      #     cmake -B build `
      #       -DGGML_CUDA=ON `
      #       -DLLAMA_CURL=OFF `
      #       -DCMAKE_BUILD_TYPE=Release `
      #       -DCMAKE_CUDA_ARCHITECTURES="60;61;70;75;80;86;89;90"
      #     cmake --build build --config Release -j $env:NUMBER_OF_PROCESSORS

      #     # Create directory structure
      #     New-Item -Path "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp" -ItemType Directory -Force

      #     # Copy binaries
      #     Copy-Item "build/bin/Release/llama-cli.exe" "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/"
      #     Copy-Item "build/bin/Release/llama-embedding.exe" "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/"

      #     # Copy required DLLs from build
      #     Copy-Item "build/bin/Release/*.dll" "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" -ErrorAction SilentlyContinue

      #     # Copy CUDA runtime DLLs
      #     $cudaPath = "C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v12.4/bin"
      #     if (Test-Path $cudaPath) {
      #       Copy-Item "$cudaPath/cublas64_12.dll" "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" -ErrorAction SilentlyContinue
      #       Copy-Item "$cudaPath/cublasLt64_12.dll" "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" -ErrorAction SilentlyContinue
      #       Copy-Item "$cudaPath/cudart64_12.dll" "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" -ErrorAction SilentlyContinue
      #     }

      #     # List compiled files
      #     Write-Host "Compiled llama.cpp files:"
      #     Get-ChildItem "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers/llama.cpp/" | Format-Table Name, Length
      #     cd "${{ github.workspace }}"

      # Download and install UPX (for pyinstaller)
      # - name: Download and install UPX (Windows)
      #   shell: bash
      #   if: runner.os == 'Windows'
      #   run: |
      #     curl -L https://github.com/upx/upx/releases/download/v4.0.2/upx-4.0.2-win64.zip -o upx.zip
      #     # Use unzip to extract the zip file
      #     unzip upx.zip -d C:/upx
      #     echo "C:/upx/upx-4.0.2-win64" >> $GITHUB_PATH

      # 6. Build the app .exe (pyinstaller)
      - name: Build app
        shell: bash
        run: |
          # PyInstaller will output to "build/Obrew-Studio" folder in root
          # Platform-specific paths handling
          if [ "$RUNNER_OS" == "Windows" ]; then
            SITE_PACKAGES=".venv/lib/site-packages"
            HNSWLIB_BINARY="$SITE_PACKAGES/hnswlib.cp312-win_amd64.pyd"
            PYINSTALLER=".venv/Scripts/pyinstaller"
            PYINSTALLER_OPTS="--onedir"
          else
            SITE_PACKAGES=".venv/lib/python3.12/site-packages"
            HNSWLIB_BINARY="$SITE_PACKAGES/hnswlib.cpython-312-darwin.so"
            PYINSTALLER=".venv/bin/pyinstaller"
            # On macOS, use --onefile to create the app bundle properly
            PYINSTALLER_OPTS="--onefile"
          fi
          # Debug: Show the paths we're using
          echo "Checking if paths exist:"
          find "$SITE_PACKAGES" -maxdepth 1 | head -20
          # Convert to absolute paths
          ABS_SITE_PACKAGES="${{ github.workspace }}/$SITE_PACKAGES"
          ABS_HNSWLIB_BINARY="${{ github.workspace }}/$HNSWLIB_BINARY"
          echo "Absolute paths:"
          echo "ABS_SITE_PACKAGES: $ABS_SITE_PACKAGES"
          echo "ABS_HNSWLIB_BINARY: $ABS_HNSWLIB_BINARY"
          $PYINSTALLER --noconfirm --clean $PYINSTALLER_OPTS --windowed \
            --log-level DEBUG \
            --contents-directory _deps \
            --icon "${{ github.workspace }}/backends/ui/favicon.ico" \
            --name "Obrew-Studio" \
            --hidden-import "tiktoken_ext.openai_public" \
            --hidden-import "tiktoken_ext" \
            --add-data "${{ github.workspace }}/public:public/" \
            --add-data "${{ github.workspace }}/package.json:public/" \
            --add-data "${{ github.workspace }}/backends/ui/public:public/" \
            --add-data "${{ github.workspace }}/certs:certs/" \
            --add-data "$ABS_SITE_PACKAGES/posthog:posthog/" \
            --add-data "$ABS_SITE_PACKAGES/chromadb:chromadb/" \
            --add-data "$ABS_SITE_PACKAGES/importlib_resources:importlib_resources/" \
            --add-data "$ABS_SITE_PACKAGES/backoff:backoff/" \
            --add-data "$ABS_SITE_PACKAGES/pypika:pypika/" \
            --add-data "$ABS_HNSWLIB_BINARY:." \
            "${{ github.workspace }}/backends/main.py"
          # Platform-specific post-build steps
          if [ "$RUNNER_OS" == "Windows" ]; then
            # Create a "servers" dir to be included in installer
            mkdir -p "${{ github.workspace }}/dist/Obrew-Studio/_deps/servers"
            # Copy and rename .env.example to .env then place in _deps/
            cp "${{ github.workspace }}/.env.example" "${{ github.workspace }}/dist/Obrew-Studio/_deps/.env"
          else
            # Run macOS app bundle creation script
            chmod +x "${{ github.workspace }}/scripts/build-macos-app-bundle.sh"
            "${{ github.workspace }}/scripts/build-macos-app-bundle.sh" "${{ github.workspace }}"
          fi

      # 7a. Package with Inno-Setup (Windows)
      - name: Create Installer (Inno-Setup)
        uses: Minionguyjpro/Inno-Setup-Action@v1.2.2
        if: runner.os == 'Windows'
        with:
          path: inno-setup-config-github.iss
          options: /O+ /dOUTPATH="${{ github.workspace }}\output" /dSOURCEPATH="${{ github.workspace }}\dist\Obrew-Studio"

      # 7b. Package with CMake/CPack (macOS/Linux)
      - name: Install CMake
        uses: lukka/get-cmake@latest
        if: runner.os != 'Windows'
        with:
          cmakeVersion: latest

      - name: Configure CMake
        shell: bash
        if: runner.os != 'Windows'
        run: |
          echo "Listing files in the GitHub workspace: ${{ github.workspace }}"
          echo "Checking dist directory for app bundle:"
          ls -la "${{ github.workspace }}/dist/" || echo "No dist directory yet"
          # Configure CMake with install prefix set to root for macOS productbuild
          cmake -S "${{ github.workspace }}" -B build_temp -DCMAKE_INSTALL_PREFIX="/"

      - name: Build Project (CMake)
        shell: bash
        if: runner.os != 'Windows'
        run: cmake --build build_temp

      - name: Debug - Verify app bundle before packaging
        shell: bash
        if: runner.os != 'Windows'
        run: |
          echo "=== DEBUGGING: Checking app bundle structure ==="
          echo "Contents of dist directory:"
          ls -la "${{ github.workspace }}/dist/"
          echo ""
          echo "Checking if app bundle exists:"
          if [ -d "${{ github.workspace }}/dist/Obrew-Studio.app" ]; then
            echo "✓ App bundle found at dist/Obrew-Studio.app"
            echo ""
            echo "App bundle top-level contents:"
            ls -la "${{ github.workspace }}/dist/Obrew-Studio.app/"
            echo ""
            echo "App bundle Contents directory:"
            ls -la "${{ github.workspace }}/dist/Obrew-Studio.app/Contents/" 2>/dev/null || echo "No Contents directory"
            echo ""
            echo "App bundle MacOS directory:"
            ls -la "${{ github.workspace }}/dist/Obrew-Studio.app/Contents/MacOS/" 2>/dev/null || echo "No MacOS directory"
            echo ""
            echo "App bundle Resources directory:"
            ls -la "${{ github.workspace }}/dist/Obrew-Studio.app/Contents/Resources/" 2>/dev/null || echo "No Resources directory"
            echo ""
            echo "App bundle Info.plist:"
            cat "${{ github.workspace }}/dist/Obrew-Studio.app/Contents/Info.plist" 2>/dev/null || echo "No Info.plist"
            echo ""
            echo "Total size of app bundle:"
            du -sh "${{ github.workspace }}/dist/Obrew-Studio.app"
          else
            echo "✗ ERROR: App bundle NOT found at dist/Obrew-Studio.app"
            echo "This will cause CPack to create an empty package!"
          fi
          echo ""
          echo "CMAKE_SOURCE_DIR will be: ${{ github.workspace }}"
          echo "CMake will look for: ${{ github.workspace }}/dist/Obrew-Studio.app"

      - name: Create Installer (CPack)
        shell: bash
        if: runner.os != 'Windows'
        run: |
          echo "Creating macOS installer package..."
          echo "Contents of dist directory before packaging:"
          ls -la "${{ github.workspace }}/dist/"
          # Run CPack with verbose output
          cd build_temp
          cpack -V
          cd "${{ github.workspace }}"
          echo "Checking output directories:"
          ls -la "${{ github.workspace }}/output" 2>/dev/null || echo "No output directory"
          ls -la "${{ github.workspace }}/build_temp" | grep -E "\.pkg|\.dmg" || echo "No packages in build_temp"

      # 9. Zip all package files/folders in /build and put in /artifacts/windows-latest/
      - name: Zip assets (Windows)
        shell: pwsh
        if: runner.os == 'Windows'
        # Ensure the output directory matches the OutputDir of CPack
        run: |
          mkdir -p ./artifacts/windows-latest
          Compress-Archive -Path "output/*.*" -DestinationPath ./artifacts/windows-latest/windows-latest-artifacts.zip

      - name: Zip assets (macOS)
        shell: bash
        if: runner.os == 'macOS'
        run: |
          mkdir -p ./artifacts/macos-latest
          # CMake/CPack creates the PKG in build_temp directory
          if [ -d "build_temp" ]; then
            cp build_temp/*.pkg ./artifacts/macos-latest/ 2>/dev/null || true
          fi
          # Also check output directory
          if [ -d "output" ]; then
            cp output/*.pkg ./artifacts/macos-latest/ 2>/dev/null || true
          fi
          # Zip all PKG files
          cd ./artifacts/macos-latest
          zip -r macos-latest-artifacts.zip *.pkg

      # 10. Upload Installer Artifact
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-artifact
          path: ./artifacts/${{ matrix.os }}/${{ matrix.os }}-artifacts.zip # upload from

  # Assumes you created a git tag already
  create_release:
    name: Create GitHub Release and Upload Assets
    needs: [build]
    runs-on: ubuntu-latest
    if: ${{ success() }}
    steps:
      - name: Download Windows artifact
        if: always()
        uses: actions/download-artifact@v4
        with:
          name: windows-latest-artifact
          path: ./artifacts/windows

      - name: Download macOS artifact
        if: always()
        uses: actions/download-artifact@v4
        with:
          name: macos-latest-artifact
          path: ./artifacts/macos

      - name: Rename artifacts
        shell: bash
        run: |
          mv ./artifacts/windows/windows-latest-artifacts.zip ./artifacts/Obrew-Studio.WIN.Setup.zip || true
          mv ./artifacts/macos/macos-latest-artifacts.zip ./artifacts/Obrew-Studio.macOS.Setup.zip || true

      - name: Create release and upload assets
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.event.inputs.ref || github.ref_name }}
          name: ${{ github.event.inputs.release_name }}
          body: ${{ github.event.inputs.release_notes }}
          draft: ${{ github.event.inputs.release_type == 'draft' }}
          prerelease: ${{ github.event.inputs.release_type == 'private' }}
          artifacts: |
            ./artifacts/Obrew-Studio.WIN.Setup.zip
            ./artifacts/Obrew-Studio.macOS.Setup.zip
          artifactContentType: application/zip
          token: ${{ secrets.GITHUB_TOKEN }}
          allowUpdates: true
          artifactErrorsFailBuild: false
